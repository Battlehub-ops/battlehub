/**
 * index.js - minimal BattleHub server (clean version)
 *
 * Paste this file into ~/battlehub/server/index.js (overwrite).
 * Then run: npm run dev   (or node index.js)
 *
 * Environment expected in .env:
 * MONGO_URI (mongodb connection string)
 * ADMIN_KEY (admin API key, default 'BattleHub2025Secret!')
 * JWT_SECRET (for requireAuth -- default 'secret')
 */

require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const mongoose = require('mongoose');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const app = express();

app.use(cors());
app.use(bodyParser.json());

// load models (assumes these files exist in ./models)
const Battle = require('./models/Battle');
const Entry = require('./models/Entry');
const Match = require('./models/Match');
const Transaction = require('./models/Transaction');
const User = require('./models/User');

const PORT = process.env.PORT || 4000;
const MONGO_URI = process.env.MONGO_URI || 'mongodb://localhost:27017/battlehub';
const ADMIN_KEY = process.env.ADMIN_KEY || 'BattleHub2025Secret!';
const JWT_SECRET = process.env.JWT_SECRET || 'secret';

/** connect to mongo */
mongoose.connect(MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => console.log('âœ… MongoDB connected successfully'))
  .catch(err => {
    console.error('MongoDB connection error', err && err.message);
  });

/** Utility: requireAuth - reads bearer token and verifies */
function requireAuth(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing auth token' });
  const token = auth.split(' ')[1];
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    // payload should contain id and email etc.
    req.user = payload;
    return next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

/** Basic admin guard */
function requireAdminKey(req, res, next) {
  const key = req.headers['x-admin-key'];
  if (!key || key !== ADMIN_KEY) return res.status(401).json({ error: 'unauthorized' });
  next();
}

/** root */
app.get('/', (req, res) => {
  res.json({ message: 'BattleHub backend running' });
});

/** List matches (optionally only unpaid) */
app.get('/matches', async (req, res) => {
  try {
    const unpaidOnly = req.query.unpaid === 'true';
    const q = {};
    if (unpaidOnly) {
      // treat unpaid matches as payoutProcessed !== true
      q.payoutProcessed = { $ne: true };
    }
    const matches = await Match.find(q)
      .sort({ createdAt: -1 })
      .populate({
        path: 'entries',
        populate: { path: 'user', select: 'name email balanceUSD' }
      })
      .populate('battle');
    res.json(matches);
  } catch (err) {
    console.error('GET /matches error', err);
    res.status(500).json({ error: err.message });
  }
});

/** Get a single battle */
app.get('/battles/:id', async (req, res) => {
  try {
    const b = await Battle.findById(req.params.id).lean();
    if (!b) return res.status(404).json({ error: 'Not found' });
    res.json(b);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/** List entries for a battle */
app.get('/battles/:id/entries', async (req, res) => {
  try {
    const entries = await Entry.find({ battle: req.params.id }).populate('user', 'name email role balanceUSD');
    res.json(entries);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Create / Register battle (open by default â€” do NOT auto-close on creation)
 */
app.post('/battles/create', requireAuth, async (req, res) => {
  try {
    const { title, sport, entryFeeUSD, startAt } = req.body || {};
    if (!title || !sport || typeof entryFeeUSD === 'undefined') {
      return res.status(400).json({ error: 'title, sport and entryFeeUSD are required' });
    }

    // Always create battles in "open" state. Matchmaking will close them when it runs.
    const battle = await Battle.create({
      title,
      sport,
      entryFeeUSD: Number(entryFeeUSD),
      startAt: startAt ? new Date(startAt) : null,
      state: 'open'
    });

    res.status(201).json({ battle });
  } catch (err) {
    console.error('Error /battles/create', err && err.message);
    res.status(500).json({ error: err.message });
  }
});

/**
 * Admin: run matchmaking for open battles
 *
 * - Only processes battles with state === 'open'
 * - Requires at least 2 entries (paid && locked) to form a match
 * - Closes the battle (state: 'closed') when processed
 * - Creates Match with seed/hash and selected winner
 */
app.post('/admin/run-matchmaking', requireAdminKey, async (req, res) => {
  try {
    const openBattles = await Battle.find({ state: 'open' }).lean();
    const processed = [];

    for (const b of openBattles) {
      // load paid+locked entries
      const entries = await Entry.find({ battle: b._id, paid: true, locked: true }).populate('user', 'name email');
      if (!entries || entries.length < 2) {
        continue;
      }

      // close the battle now to avoid race conditions
      await Battle.findByIdAndUpdate(b._id, { state: 'closed' });

      // compute pot and cuts
      const potUSD = entries.reduce((s) => s + (b.entryFeeUSD || 0), 0); // each entry pays battle.entryFeeUSD
      // If pot computed as entries.length * entryFeeUSD:
      const pot = Number((entries.length * (b.entryFeeUSD || 0)).toFixed(2));
      const platformCutUSD = Number((pot * 0.15).toFixed(2)); // 15% platform cut - adjust as needed
      const winnerPayoutUSD = Number((pot - platformCutUSD).toFixed(2));

      // reproducible seed/hash + selection
      const seedData = crypto.randomBytes(32).toString('hex') + '|' + Date.now();
      const recomputedHash = crypto.createHash('sha256').update(seedData).digest('hex');
      const chosenIndex = parseInt(recomputedHash.slice(0, 8), 16) % entries.length;
      const winnerEntry = entries[chosenIndex];

      const match = await Match.create({
        battle: b._id,
        entries: entries.map(e => e._id),
        winnerEntry: winnerEntry._id,
        potUSD: pot,
        winnerPayoutUSD,
        platformCutUSD,
        seed: seedData,
      });

      processed.push({
        battleId: String(b._id),
        matchId: String(match._id),
        winnerEntry: String(winnerEntry._id)
      });
    }

    res.json({ ok: true, processed });
  } catch (err) {
    console.error('POST /admin/run-matchmaking error', err);
    res.status(500).json({ error: err.message });
  }
});

/** Admin: verify match seed/hash + selection */
app.get('/admin/match/:id/verify', requireAdminKey, async (req, res) => {
  try {
    const m = await Match.findById(req.params.id).populate({
      path: 'entries',
      populate: { path: 'user', select: 'email name' }
    });
    if (!m) return res.status(404).json({ error: 'Not found' });

    const storedSeed = m.seed || '';
    const recomputedHash = crypto.createHash('sha256').update(storedSeed).digest('hex');
    const chosenIndex = (m.entries && m.entries.length) ? parseInt(recomputedHash.slice(0, 8), 16) % m.entries.length : null;

    res.json({
      matchId: m._id,
      storedSeed,
      recomputedHash,
      seedsMatch: true,
      chosenIndex,
      entries: (m.entries || []).map((e, idx) => ({
        index: idx,
        id: String(e._id),
        userEmail: e.user && e.user.email,
        userName: e.user && e.user.name
      })),
      winnerEntryId: String(m.winnerEntry)
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/** Admin: payout a single match (credits winner balance and records transactions) */
app.post('/admin/payout/:matchId', requireAdminKey, async (req, res) => {
  try {
    const match = await Match.findById(req.params.matchId).populate({
      path: 'entries',
      populate: { path: 'user', select: 'balanceUSD' }
    });
    if (!match) return res.status(404).json({ error: 'Match not found' });

    if (match.payoutProcessed) {
      return res.status(400).json({ error: 'Payout already processed for this match', matchId: match._id });
    }

    // Determine winner user id
    const winnerEntryId = match.winnerEntry;
    const winnerEntry = match.entries.find(e => String(e._id) === String(winnerEntryId));
    if (!winnerEntry) {
      return res.status(400).json({ error: 'Winner entry not found in match' });
    }
    const winnerUserId = winnerEntry.user ? winnerEntry.user._id : null;
    if (!winnerUserId) {
      return res.status(400).json({ error: 'Winner user not found' });
    }

    // Credit user balance
    const winnerPayout = Number(match.winnerPayoutUSD || 0);
    const platformCut = Number(match.platformCutUSD || 0);

    const user = await User.findById(winnerUserId);
    if (!user) return res.status(404).json({ error: 'Winner user not found' });

    user.balanceUSD = Number((Number(user.balanceUSD || 0) + winnerPayout).toFixed(2));
    await user.save();

    // Create transactions
    await Transaction.create({
      user: winnerUserId,
      match: match._id,
      amountUSD: winnerPayout,
      type: 'payout',
      note: `Payout for match ${match._id}`
    });

    await Transaction.create({
      user: null,
      match: match._id,
      amountUSD: platformCut,
      type: 'platform_fee',
      note: `Platform cut for match ${match._id}`
    });

    // mark match as paid/processed
    match.paid = true;
    match.payoutProcessed = true;
    match.payoutAt = new Date();
    await match.save();

    res.json({
      ok: true,
      matchId: String(match._id),
      winnerUserId: String(winnerUserId),
      updatedBalanceUSD: user.balanceUSD,
      winnerPayoutUSD: winnerPayout,
      platformCutUSD: platformCut
    });
  } catch (err) {
    console.error('POST /admin/payout error', err);
    res.status(500).json({ error: err.message });
  }
});

/** Admin: summary, users, transactions endpoints (simple) */
app.get('/admin/summary', requireAdminKey, async (req, res) => {
  try {
    const totalUsers = await User.countDocuments();
    const totalBattles = await Battle.countDocuments();
    const totalMatches = await Match.countDocuments();
    const totalPayoutsAgg = await Transaction.aggregate([
      { $match: { type: 'payout' } },
      { $group: { _id: null, sum: { $sum: '$amountUSD' } } }
    ]);
    const platformAgg = await Transaction.aggregate([
      { $match: { type: 'platform_fee' } },
      { $group: { _id: null, sum: { $sum: '$amountUSD' } } }
    ]);
    const unpaidMatchesCount = await Match.countDocuments({ payoutProcessed: { $ne: true } });

    res.json({
      totalUsers,
      totalBattles,
      totalMatches,
      totalPayoutsUSD: (totalPayoutsAgg[0] && totalPayoutsAgg[0].sum) || 0,
      platformRevenueUSD: (platformAgg[0] && platformAgg[0].sum) || 0,
      unpaidMatchesCount
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get('/admin/users', requireAdminKey, async (req, res) => {
  const users = await User.find().sort({ createdAt: -1 });
  res.json(users);
});

app.get('/admin/transactions', requireAdminKey, async (req, res) => {
  const transactions = await Transaction.find().sort({ createdAt: -1 });
  res.json(transactions);
});

/** Start server */
app.listen(PORT, () => {
  console.log(`ðŸš€ BattleHub server listening on port ${PORT}`);
});


/**
 * Join a battle (create an entry)
 * - requires requireAuth middleware that sets req.user (existing in your index.js)
 * - creates an Entry with paid=true, locked=true for test / admin flows
 */
app.post('/battles/:id/join', requireAuth, async (req, res) => {
  try {
    const battleId = req.params.id;
    const user = req.user; // should be set by requireAuth
    if (!user || !user._id) return res.status(401).json({ error: 'Not authenticated' });

    const battle = await Battle.findById(battleId);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });

    // Only allow joining when battle is explicitly "open"
    if (battle.state !== 'open') {
      return res.status(400).json({ error: 'Battle not open' });
    }

    // prevent duplicate joins
    const already = await Entry.findOne({ battle: battleId, user: user._id });
    if (already) return res.status(400).json({ error: 'User already joined this battle' });

    // ensure user has enough balance (if you want this checked)
    if (typeof battle.entryFeeUSD === 'number' && Number(battle.entryFeeUSD) > 0) {
      const u = await User.findById(user._id);
      if (!u) return res.status(404).json({ error: 'User not found' });
      if ((u.balanceUSD || 0) < Number(battle.entryFeeUSD)) {
        return res.status(400).json({ error: 'Insufficient balance to join' });
      }
      // Deduct fee from user balance and save
      u.balanceUSD = Number(u.balanceUSD || 0) - Number(battle.entryFeeUSD);
      await u.save();
    }

    // create entry â€” mark paid & locked so matchmaking can run on it
    const entry = await Entry.create({
      user: user._id,
      battle: battleId,
      stripeSessionId: null,
      paid: true,
      locked: true
    });

    res.status(201).json({ message: 'Entry created (paid=true, locked=true)', entry });
  } catch (err) {
    console.error('POST /battles/:id/join error', err && err.message);
    res.status(500).json({ error: err.message || String(err) });
  }
});
