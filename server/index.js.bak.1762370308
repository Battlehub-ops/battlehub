// index.js (clean base)
require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

const app = express();
app.use(cors());
app.use(express.json());

// --- Models ---
const User = require('./models/User');
const Battle = require('./models/Battle');
const Entry = require('./models/Entry');
const Match = require('./models/Match');

// --- JWT & Admin key placeholders (set in .env) ---
const JWT_SECRET = process.env.JWT_SECRET || 'dev_jwt_secret';
const TOKEN_EXPIRY = '7d';
const ADMIN_KEY = process.env.ADMIN_KEY || 'change_this_admin_key';

// --- Auth helpers (minimal) ---
function signToken(user) {
  const payload = { id: user._id.toString(), email: user.email, role: user.role || 'user' };
  return jwt.sign(payload, JWT_SECRET, { expiresIn: TOKEN_EXPIRY });
}
function requireAuth(req, res, next) {
  try {
    const auth = req.headers.authorization || '';
    if (!auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing auth token' });
    const token = auth.slice(7);
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    return next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}
function requireRole(role) {
  return (req, res, next) => {
    if (!req.user) return res.status(401).json({ error: 'Not authenticated' });
    if (req.user.role !== role) return res.status(403).json({ error: 'Forbidden - insufficient role' });
    next();
  };
}
function requireAdminKey(req, res, next) {
  const key = req.headers['x-admin-key'] || req.query.admin_key;
  if (!key || key !== ADMIN_KEY) return res.status(401).json({ error: 'unauthorized - admin key required' });
  next();
}

// --- Connect to MongoDB ---
const uri = process.env.MONGO_URI;
if (!uri) {
  console.error('âŒ MONGO_URI not found in .env');
  process.exit(1);
}
console.log('ðŸ”Œ Connecting to MongoDB...');
mongoose.connect(uri)
  .then(() => console.log('âœ… MongoDB connected successfully'))
  .catch(err => {
    console.error('âŒ MongoDB connection error:', err.message);
    process.exit(1);
  });

// --- Simple routes for sanity ---
app.get('/', (req, res) => res.json({ message: 'BattleHub backend running' }));

// Basic user register/login (no validation beyond minimal)
app.post('/users/register', async (req, res) => {
  try {
    const { email, name, password } = req.body;
    if (!email) return res.status(400).json({ error: 'Email required' });
    let user = await User.findOne({ email });
    if (user) return res.status(409).json({ error: 'User exists' });
    const hash = password ? await bcrypt.hash(password, 10) : undefined;
    user = await User.create({ email, name, password: hash });
    const token = signToken(user);
    res.status(201).json({ user, token });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});
app.post('/users/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email) return res.status(400).json({ error: 'Email required' });
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: 'User not found' });
    if (user.password) {
      if (!password) return res.status(400).json({ error: 'Password required' });
      const ok = await bcrypt.compare(password, user.password);
      if (!ok) return res.status(401).json({ error: 'Invalid password' });
    }
    const token = signToken(user);
    res.json({ user, token });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }

// Create / Register battle (open by default â€” do NOT auto-close on creation)
app.post('/battles/create', requireAuth, async (req, res) => {
  try {
    const { title, sport, entryFeeUSD, startAt } = req.body || {};
    if (!title || !sport || typeof entryFeeUSD === 'undefined') {
      return res.status(400).json({ error: 'title, sport and entryFeeUSD are required' });
    }

    // Always create battles in "open" state. Matchmaking will close them when it runs.
    const battle = await Battle.create({
      title,
      sport,
      entryFeeUSD: Number(entryFeeUSD),
      startAt: startAt ? new Date(startAt) : null,
      state: 'open'
    });

    res.status(201).json({ battle });
  } catch (err) {
    console.error('Error /battles/create', err && err.message);
    res.status(500).json({ error: err.message });
  }
});

// List battles (public)
app.get('/battles', async (req, res) => {
  try {
    const list = await Battle.find().sort({ startAt: 1 });
    res.json(list);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Join a battle (requires auth; battle must be in 'open' state)
app.post('/battles/:id/join', requireAuth, async (req, res) => {
  try {
    const battleId = req.params.id;
    const userId = req.user && req.user.id;
    if (!userId) return res.status(401).json({ error: 'Not authenticated' });

    const battle = await Battle.findById(battleId);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });

    // Only allow joining when battle is explicitly open
    if (battle.state !== 'open') {
      return res.status(400).json({ error: 'Battle not open' });
    }

    // (Simplified test-mode entry creation) - real flow would integrate payment
    const existing = await Entry.findOne({ battle: battle._id, user: userId });
    if (existing) {
      return res.status(409).json({ error: 'Already joined', entry: existing });
    }

    const entry = await Entry.create({
      user: userId,
      battle: battle._id,
      stripeSessionId: null,
      paid: true,   // test mode: mark as paid so it participates
      locked: false
    });

    res.json({ message: 'Entry created (test mode, paid=true)', entry });
  } catch (err) {
    console.error('Error /battles/:id/join', err && err.message);
    res.status(500).json({ error: err.message });
  }
});

// List entries for a battle (public)
app.get('/battles/:id/entries', async (req, res) => {
  try {
    const entries = await Entry.find({ battle: req.params.id }).populate('user');
    res.json(entries);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Admin: run matchmaking for open battles (requires ADMIN_KEY)
app.post('/admin/run-matchmaking', requireAdminKey, async (req, res) => {
  try {
    const processed = [];

    // find open battles
    const openBattles = await Battle.find({ state: 'open' });

    for (const b of openBattles) {
      // get paid & unlocked entries for this battle
      const entries = await Entry.find({ battle: b._id, paid: true, locked: false }).populate('user');
      if (!entries || entries.length < 2) continue; // need at least 2

      // lock these entries
      await Entry.updateMany(
        { battle: b._id, paid: true, locked: false },
        { $set: { locked: true } }
      );

      // create a reproducible seed
      const seed = crypto.randomBytes(32).toString('hex') + '|' + Date.now().toString();

      // derive deterministic number from seed (sha256 -> bigint -> mod n)
      const hash = crypto.createHash('sha256').update(seed).digest('hex');
      const num = BigInt('0x' + hash);
      const idx = Number(num % BigInt(entries.length));

      const winnerEntry = entries[idx];

      // compute pot and payouts
      const potUSD = (entries.length) * (b.entryFeeUSD || 0);
      const winnerPayoutUSD = +(potUSD * 0.85).toFixed(2);
      const platformCutUSD = +(potUSD - winnerPayoutUSD).toFixed(2);

      // create match record
      const match = await Match.create({
        battle: b._id,
        entries: entries.map(e => e._id),
        winnerEntry: winnerEntry._id,
        potUSD,
        winnerPayoutUSD,
        platformCutUSD,
        seed: seed // store seed for later audit
      });

      // mark battle closed
      b.state = 'closed';
      await b.save();

      processed.push({ battleId: b._id.toString(), matchId: match._id.toString(), winnerEntry: winnerEntry._id.toString() });
    }

    res.json({ ok: true, processed });
  } catch (err) {
    console.error('run-matchmaking error', err);
    res.status(500).json({ error: err.message });
  }
});

// Admin: verify a match (provable fairness) - FIXED
app.get('/admin/match/:id/verify', requireAdminKey, async (req, res) => {
  try {
    const matchId = req.params.id;
    const match = await Match.findById(matchId).populate('entries').lean();
    if (!match) return res.status(404).json({ error: 'Match not found' });

    const storedSeed = match.seed || ''; // expected "hexseed|timestamp" (or any full seed string)
    if (!storedSeed) {
      return res.status(400).json({ error: 'No seed stored for this match' });
    }

    // recompute hash using the full stored seed (must match how matchmaking computed it)
    const recomputedHash = crypto.createHash('sha256').update(storedSeed).digest('hex');
    const num = BigInt('0x' + recomputedHash);

    // load entries used in the match in the same order
    const detailedEntries = await Entry.find({ _id: { $in: match.entries } }).populate('user');
    const entries = detailedEntries || [];
    const chosenIndex = entries.length ? Number(num % BigInt(entries.length)) : null;

    res.json({
      matchId,
      storedSeed,
      recomputedHash,
      chosenIndex,
      entries: entries.map((e, idx) => ({
        index: idx,
        id: e._id.toString(),
        userEmail: e.user?.email,
        userName: e.user?.name
      })),
      winnerEntryId: match.winnerEntry?.toString()
    });
  } catch (err) {
    console.error('verify match error', err);
    res.status(500).json({ error: err.message });
  }
});

// Admin: process payout for a match (credit winner balance & record transactions)
app.post('/admin/payout/:matchId', requireAdminKey, async (req, res) => {
  try {
    const matchId = req.params.matchId;
    const Match = require('./models/Match');
    const Entry = require('./models/Entry');
    const User = require('./models/User');
    const Transaction = require('./models/Transaction');

    // load match (not lean because we may update)
    const match = await Match.findById(matchId);
    if (!match) return res.status(404).json({ error: 'Match not found' });

    // disallow double payouts
    if (match.payoutProcessed || match.paid) {
      return res.status(400).json({ error: 'Payout already processed for this match', matchId });
    }

    const winnerEntryId = match.winnerEntry;
    const potUSD = Number(match.potUSD || 0);
    const winnerPayoutUSD = Number(match.winnerPayoutUSD || 0);
    const platformCutUSD = Number(match.platformCutUSD || 0);

    if (!winnerEntryId) return res.status(400).json({ error: 'No winnerEntry recorded on match' });

    const winnerEntry = await Entry.findById(winnerEntryId).lean();
    if (!winnerEntry) return res.status(404).json({ error: 'Winner entry not found' });

    const winnerUserId = winnerEntry.user;
    if (!winnerUserId) return res.status(400).json({ error: 'Winner entry missing user' });

    // credit winner's balance (atomic update)
    const updatedUser = await User.findByIdAndUpdate(
      winnerUserId,
      { $inc: { balanceUSD: winnerPayoutUSD } },
      { new: true }
    ).lean();

    // record transaction for winner
    await Transaction.create({
      user: winnerUserId,
      match: match._id,
      amountUSD: winnerPayoutUSD,
      type: 'payout',
      note: `Payout for match ${match._id} (pot: ${potUSD}, platform cut: ${platformCutUSD})`
    });

    // record platform cut transaction (user: null)
    if (platformCutUSD && platformCutUSD > 0) {
      await Transaction.create({
        user: null,
        match: match._id,
        amountUSD: platformCutUSD,
        type: 'platform_fee',
        note: `Platform cut for match ${match._id}`
      });
    }

    // mark match as paid/payoutProcessed
    match.paid = true;
    match.payoutProcessed = true;
    match.payoutAt = new Date();
    await match.save();

    res.json({
      ok: true,
      matchId: match._id,
      winnerUserId,
      updatedBalanceUSD: updatedUser.balanceUSD,
      winnerPayoutUSD,
      platformCutUSD
    });
  } catch (err) {
    console.error('admin payout error', err);
    res.status(500).json({ error: err.message });
  }
});

// Admin: list recent transactions (protected by ADMIN_KEY)
app.get('/admin/transactions', requireAdminKey, async (req, res) => {
  try {
    const Transaction = require('./models/Transaction');
    const txs = await Transaction.find().sort({ createdAt: -1 }).limit(200).lean();
    res.json(txs);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Admin: list users (protected by ADMIN_KEY) â€” exclude passwords
app.get('/admin/users', requireAdminKey, async (req, res) => {
  try {
    const User = require('./models/User');
    // exclude password field at query level
    const users = await User.find().select('-password').sort({ createdAt: -1 }).lean();
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Admin: dashboard summary (protected)
app.get('/admin/summary', requireAdminKey, async (req, res) => {
  try {
    const User = require('./models/User');
    const Battle = require('./models/Battle');
    const Match = require('./models/Match');
    const Transaction = require('./models/Transaction');

    const totalUsers = await User.countDocuments();
    const totalBattles = await Battle.countDocuments();
    const totalMatches = await Match.countDocuments();

    // sum payouts and platform fees
    const payoutsAgg = await Transaction.aggregate([
      { $match: { type: { $in: ['payout','platform_fee'] } } },
      { $group: { _id: '$type', total: { $sum: '$amountUSD' } } }
    ]);

    let totalPayoutsUSD = 0;
    let platformRevenueUSD = 0;
    for (const r of payoutsAgg) {
      if (r._id === 'payout') totalPayoutsUSD = r.total;
      if (r._id === 'platform_fee') platformRevenueUSD = r.total;
    }

    const unpaidMatchesCount = await Match.countDocuments({
      winnerEntry: { $exists: true, $ne: null },
      $or: [{ payoutProcessed: { $exists: false } }, { payoutProcessed: false }]
    });

    res.json({
      totalUsers,
      totalBattles,
      totalMatches,
      totalPayoutsUSD,
      platformRevenueUSD,
      unpaidMatchesCount
    });
  } catch (err) {
    console.error('admin summary error', err);
    res.status(500).json({ error: err.message });
  }
});

// --- Flutterwave: initiate a payment (test mode) ---
// POST /payments/initiate
// body: { userId, amountUSD }
// returns: { ok: true, link: "<payment_url>" } on success
const axios = require('axios');

app.post('/payments/initiate', async (req, res) => {
  try {
    const { userId, amountUSD } = req.body;
    if (!userId || !amountUSD) return res.status(400).json({ error: 'userId and amountUSD required' });

    // load user to get email/name
    const User = require('./models/User');
    const user = await User.findById(userId).lean();
    if (!user) return res.status(404).json({ error: 'User not found' });

    // Build a unique tx_ref (transaction reference)
    const tx_ref = `battlehub_${userId}_${Date.now()}`;

    // Flutterwave create payment payload (v3 payments)
    const payload = {
      tx_ref,
      amount: Number(amountUSD).toFixed(2),
      currency: "USD",
      redirect_url: `${process.env.BASE_URL}/payments/complete`, // user flows back here after paying (we'll handle later)
      customer: {
        email: user.email,
        name: user.name || 'BattleHub User'
      },
      customization: {
        title: "BattleHub Deposit",
        description: `Deposit USD ${amountUSD} to BattleHub account`
      },
      meta: {
        userId,
        platform: "BattleHub"
      },
      // allow multiple payment options (cards + mobile money where supported)
      payment_options: "card,mobilemoneyuganda,mobilemoneyrwanda,mobilemoneyzambia,ussd"
    };

    const FLW_SECRET = process.env.FLW_SECRET_KEY;
    if (!FLW_SECRET) return res.status(500).json({ error: 'FLW_SECRET_KEY not configured' });

    const resp = await axios.post('https://api.flutterwave.com/v3/payments', payload, {
      headers: {
        Authorization: `Bearer ${FLW_SECRET}`,
        'Content-Type': 'application/json'
      }
    });

    // Flutterwave returns data; we forward the payment link (if present) to the client
    const data = resp.data;
    if (!data || !data.status || data.status !== 'success') {
      // Something unexpected; forward the whole response for debugging
      return res.status(500).json({ error: 'Flutterwave error', raw: data });
    }

    // Depending on Flutterwave response, the payment link may be at data.data.link or data.data.checkout_url
    const link = (data.data && (data.data.link || data.data.checkout_url || data.data.redirect || null)) || null;

    if (!link) {
      // Forward response so you can inspect fields in your sandbox
      return res.status(200).json({ ok: true, raw: data });
    }

    // Save a pending deposit entry if you want (optional)
    // You can create a Deposit model later; for now just return link
    res.json({ ok: true, link, tx_ref, raw: data });
  } catch (err) {
    console.error('payments/initiate error', err?.response?.data || err.message || err);
    res.status(500).json({ error: err?.response?.data || err.message || 'server error' });
  }
});

// List matches (optionally only unpaid)
app.get('/matches', async (req, res) => {
  try {
    const unpaidOnly = req.query.unpaid === 'true';
    const q = {};
    if (unpaidOnly) {
      // We treat unpaid matches as those with payoutProcessed: false (or paid: false)
      q.payoutProcessed = { $ne: true };
    }
    const matches = await Match.find(q)
      .sort({ createdAt: -1 })
      .populate({
        path: 'entries',
        populate: { path: 'user', select: 'name email balanceUSD' }
      })
      .populate('battle');
    res.json(matches);
  } catch (err) {
    console.error('GET /matches error', err);
    res.status(500).json({ error: err.message });
  }
});

// GET /matches/:id - view single match detail
app.get('/matches/:id', async (req, res) => {
  try {
    const match = await Match.findById(req.params.id)
      .populate({
        path: 'battle',
        select: 'title sport entryFeeUSD startAt state'
      })
      .populate({
        path: 'entries',
        populate: {
          path: 'user',
          select: 'name email balanceUSD'
        }
      });

    if (!match) {
      return res.status(404).json({ error: 'Match not found' });
    }

    res.json(match);
  } catch (err) {
    console.error('Error fetching match', err);
    res.status(500).json({ error: err.message });
  }
});

// --- Batch payout admin route (starts payout-unpaid.js safely) ---
const { execFile } = require('child_process');
const path = require('path');

// simple in-process lock to prevent concurrent runs
let payoutRunning = false;

/**
 * POST /admin/payout-unpaid
 * - Requires admin key (use your existing requireAdminKey middleware)
 * - Starts scripts/payout-unpaid.js --apply as a child Node process
 * - Returns immediately with a status; process continues in background
 */
app.post('/admin/payout-unpaid', requireAdminKey, (req, res) => {
  try {
    if (payoutRunning) {
      return res.status(409).json({ ok: false, error: 'Batch payout already running' });
    }

    const scriptPath = path.join(__dirname, 'scripts', 'payout-unpaid.js');

    // mark running
    payoutRunning = true;

    // spawn a Node child process to run the script
    const child = execFile(process.execPath, [scriptPath, '--apply'], {
      env: process.env,
      cwd: path.join(__dirname),
      maxBuffer: 10 * 1024 * 1024, // 10MB buffer
    }, (err, stdout, stderr) => {
      // callback after child exits (or error)
      payoutRunning = false;

      if (stdout && stdout.length) console.log('[payout-unpaid stdout]\n', stdout);
      if (stderr && stderr.length) console.error('[payout-unpaid stderr]\n', stderr);

      if (err) {
        console.error('Batch payout script finished with error:', err && err.message);
      } else {
        console.log('Batch payout script finished successfully.');
      }
    });

    // Immediately respond to admin request so UI is not blocked
    res.json({ ok: true, message: 'Batch payout started' });
  } catch (err) {
    payoutRunning = false;
    console.error('Error starting batch payout:', err);
    res.status(500).json({ ok: false, error: err.message });
  }
});

// Start server
const PORT = process.env.PORT || 4000;
app.listen(PORT, () => console.log(`ðŸš€ BattleHub server listening on port ${PORT}`));

